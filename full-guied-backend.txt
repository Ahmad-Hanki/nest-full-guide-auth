// local strategy only used to sign in => user login (email/password)
// JWT => protect APIs (like /user/me)
// Refresh JWT => keep user logged in
// (Optional) Google/Github

1- Sign up a new user
normal sign up
) apps\api\src\auth\auth.controller.ts
) apps\api\src\auth\auth.service.ts
) apps\api\src\user\user.service.ts

2- Sign in with user name and password
) apps\api\src\auth\auth.controller.ts
// npm i passport @nestjs/passport passport-local @types/passport-local
) apps\api\src\auth\strategies\local-strategy.ts
) apps\api\src\auth\auth.service.ts
// only for login


now we go to the local guard
// apps\api\src\auth\guards\local-auth\local-auth.guard.ts
// apps\api\src\auth\auth.controller.ts   @UseGuards(LocalAuthGuard)


3- protect apis with jwt
// now we create jwt tokens
npm i @nestjs/jwt @nestjs/config
) apps\api\src\auth\auth.module.ts
) apps\api\.env
) apps\api\src\auth\config\jwt.config.ts
) apps\api\src\auth\auth.controller.ts
) apps\api\src\auth\auth.service.ts

// no we created the access token, we need to crate a strategy to protect our routes using passport
npm i passport-jwt @types/passport-jwt
) apps\api\src\auth\strategies\jwt-strategy.ts
) apps\api\src\auth\auth.service.ts
) apps\api\src\user\user.service.ts
nest g gu auth/guards/jwt-auth
) apps\api\src\auth\guards\jwt-auth\jwt-auth.guard.ts
) apps\api\src\auth\auth.module.ts



4- refresh token
) apps\api\.env
) apps\api\src\auth\config\refresh-jwt.config.ts
) apps\api\src\auth\auth.service.ts
) apps\api\src\auth\auth.module.ts

// now after generating the refresh token, we start with the implementing the refresh access token
) apps\api\src\auth\strategies\refresh-token-strategy.ts
) apps\api\src\auth\auth.service.ts
) apps\api\src\auth\guards\refresh-jwt-auth\refresh-jwt-auth.guard.ts
) apps\api\src\auth\auth.module.ts
) apps\api\src\auth\auth.controller.ts
) apps\api\src\auth\auth.service.ts

5- Google 0Auth
check the other file

6- revoke token or token invalidation => means canceling or invalidating a token, so it canâ€™t be used anymore for login or API access.

// in login function we hash the refresh token first and store in in the users data
) apps\api\src\auth\auth.service.ts
// updateHashedRefreshToken
) apps\api\src\user\user.service.ts

// now we need to go to the refresh token strategy and inside the validate function we need to extract the refresh token from the body request
// we gonna compare the hashed token in our db with the body and then 
// invalidate it inside the validateRefreshToken function

// validateRefreshToken gets the refresh token
) apps\api\src\auth\auth.service.ts
// refreshTokens to

// until here we didnt do anything but storing the refresh token in the db

) apps\api\src\auth\auth.controller.ts  @Post('signout')

7- Role based access control

8- public routes

9- nestjs config